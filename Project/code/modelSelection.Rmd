---
title: "Model Selection"
author: "Michelle Evans"
date: "11/22/2017"
output: html_document
---

```{r setup, include=FALSE}
#wd should be set to Project folder (not RProject)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir="../") #set wd to proj directory
```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(viridis)
library(nlme)
library(lme4)
library(MuMIn)
library(glmmADMB)
```

```{r}
emergenceData <- readRDS("data/emergence.RData")
survival <- readRDS("data/survival.RData")
fecundity <- readRDS("data/fecundity.RData")
AedesAll <- readRDS("data/AedesIndividualSurvival.RData")
```

This document goes through model selection for each analysis section of the ms.

# Survival

## Aedes

Survival (or prob. of emergence) is a binary variable per individual mosquito. I use a generalized linear mixed model to explore the effect of Aedes density, Stephensi density, and temperature on emergence, with replicate as a random intercept. The data is subset to that of females (this can differ as males tend to develop more quickly and will emerge first). Predictor variables are normalized/scaled.

Reformat data into successes and failures per jar.
```{r format survival data}
aeSurvival <- emergenceData %>%
  filter(Species == "Aedes" & AeDens!= 0 & Sex == "Female") %>%
  group_by(Replicate, Temp, TempNum, AeDens, StDens, Ratio) %>%
  summarise(success = sum(Number, na.rm = T)) %>%
  mutate(failure = (AeDens/2) - success) %>%
  ungroup() %>%
  #rescale predictor variables
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T))) %>%
  #drop jar that was all male
  filter(!(Replicate == "A" & Temp == "24" & Ratio == "8:24"))
  
#for when more than 50% were female
aeSurvival$failure[aeSurvival$failure<0] <- 0
```

Aedes model selection
```{r}
m0 <- glmer(cbind(success, failure) ~ 1 + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))
m1 <- glmer(cbind(success, failure) ~ AeDensScale + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))
m2 <- glmer(cbind(success, failure) ~ AeDensScale + TempNum + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))
m3 <- glmer(cbind(success, failure) ~ AeDensScale + poly(TempNum,2) + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))
m4 <- glmer(cbind(success, failure) ~ AeDensScale*poly(TempNum,2) + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))

m5 <- glmer(cbind(success, failure) ~ AeDensScale + poly(TempNum,2) + StDensScale + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))

m6 <- glmer(cbind(success, failure) ~ AeDensScale + poly(TempNum,2) * StDensScale + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))

m7 <- glmer(cbind(success, failure) ~ AeDensScale + poly(TempNum,2) + StDensScale + TempNum:StDensScale + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))

m8 <- glmer(cbind(success, failure) ~ AeDensScale*poly(TempNum,2) + StDensScale*poly(TempNum,2) + (1|Replicate),
                   data = aeSurvival,
                   family = binomial(link = "logit"))

modelSummary <- cbind(model = c("m0","m1","m2","m3", "m4", "m5", "m6", "m7" , "m8"), 
                   do.call(rbind, lapply(list(m0, m1, m2, m3, m4, m5, m6, m7, m8), broom::glance)),
                   AICc = AICc(m0, m1, m2, m3, m4, m5, m6, m7, m8), 
                   AICweights = Weights(AIC(m0, m1, m2, m3, m4, m5, m6, m7, m8)))
modelSummary
anova(m6,m7, m8)

AedesSurvivalModel <- m7

```

Based on the above, model 7 (survival ~ AeDens + StDens + Temp^2 + StDens:Temp) fits best. Model 6 fits similary, but has an additional term of an interaction between polynomial temperature and stephensi density, and so the more parismonious model is chosen. Now we explore model residuals.

```{r}
plot(AedesSurvivalModel, id = 0.01, idLabels=~.obs)
qqnorm(resid(AedesSurvivalModel))
qqline(resid(AedesSurvivalModel), col = "red")

aeSurvival$preds <- predict(AedesSurvivalModel)
aeSurvival$resids <- resid(AedesSurvivalModel)

ggplot(data = aeSurvival, aes(x=StDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = aeSurvival, aes(x=AeDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = aeSurvival, aes(x=TempNum, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

```

The residuals for this model are slightly heteroskedastic, but I think are fine in general.

```{r}
summary(AedesSurvivalModel)

confint(AedesSurvivalModel)
```

Plot predicted values in a heatmap.

```{r}
#heatmap plots
newData <- expand.grid(AeDens=seq(0,128, by=2), StDens=seq(0,128, by=2), TempNum=c(16,20,24,28,32), Replicate = c("A", "B"))
newData <- newData %>%
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T)))

newData$preds <- predict(AedesSurvivalModel, type = "response", newdata = newData)
#get means over replicates to plot
predicted <- newData %>%
  group_by(TempNum, AeDens, StDens) %>%
  summarise(preds = mean(preds))
#remove extrapolation outside of measured range
predicted$preds[predicted$AeDens+predicted$StDens>128] <- NA  

#plot it
ggplot(predicted, aes(x=StDens, y=AeDens, z=preds))+
  geom_raster(aes(fill=preds))+
  geom_contour(color="gray90")+
  theme_minimal()+
  scale_fill_viridis(name="Prop. Emerged")+
  facet_wrap(~TempNum, ncol = 5) +
  xlab("Stephensi Density") +
  ylab("Aegypti Density")
```

## Stephensi

```{r}
#stephensi
stSurvival <- emergenceData %>%
  filter(Species == "Stephensi" & StDens!= 0 & Sex == "Female") %>%
  group_by(Replicate, Temp, TempNum, AeDens, StDens, Ratio) %>%
  summarise(success = sum(Number, na.rm = T)) %>%
  mutate(failure = (StDens/2) - success) %>%
  ungroup() %>%
  #rescale predictor variables
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T)))
#for when more than 50% were female
stSurvival$failure[stSurvival$failure<0] <- 0
```

Stephensi model selection
```{r}
m0 <- glmer(cbind(success, failure) ~ 1 + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))
m1 <- glmer(cbind(success, failure) ~ StDensScale + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))
m2 <- glmer(cbind(success, failure) ~ StDensScale + TempScale + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))
m3 <- glmer(cbind(success, failure) ~ StDensScale + poly(TempScale,2) + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))
m4 <- glmer(cbind(success, failure) ~ StDensScale*poly(TempScale,2) + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))

m5 <- glmer(cbind(success, failure) ~ StDensScale + poly(TempScale,2) + AeDensScale + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))

m6 <- glmer(cbind(success, failure) ~ StDensScale + poly(TempScale,2) * AeDensScale + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))

m7 <- glmer(cbind(success, failure) ~ StDensScale + poly(TempScale,2) + AeDensScale + TempScale:StDensScale + (1|Replicate),
                   data = stSurvival,
                   family = binomial(link = "logit"))

modelSummary <- cbind(model = c("m0","m1","m2","m3", "m4", "m5", "m6", "m7"), 
                   do.call(rbind, lapply(list(m0, m1, m2, m3, m4, m5, m6, m7), broom::glance)),
                   AICc = AICc(m0, m1, m2, m3, m4, m5, m6, m7), 
                   AICweights = Weights(AIC(m0, m1, m2, m3, m4, m5, m6, m7)))
modelSummary

anova(m6,m7)

StephSurvivalModel <- m7
```

For stephensi, model m7 is the best fit (survival ~ AeDens + Temp^2 + StDens + Temp^2*StDens)

```{r}
plot(StephSurvivalModel, id = 0.01, idLabels=~.obs)
qqnorm(resid(StephSurvivalModel))
qqline(resid(StephSurvivalModel), col = "red")

stSurvival$preds <- predict(StephSurvivalModel)
stSurvival$resids <- resid(StephSurvivalModel)

ggplot(data = stSurvival, aes(x=factor(StDens), y = resids))+
  geom_boxplot() +
  geom_line(aes(y=0), color="red") +
  theme_base()

ggplot(data = stSurvival, aes(x=factor(AeDens), y = resids))+
  geom_boxplot() +
  theme_base()

ggplot(data = stSurvival, aes(x=Temp, y = resids))+
  geom_boxplot() +
  theme_base()

ggplot(data = stSurvival, aes(x=Replicate, y = resids))+
  geom_boxplot() +
  theme_base()

```

The residuals on this model look very bad. Not sure what to do.

Now we can predict over the response surface.

```{r}
#heatmap plots
newData <- expand.grid(AeDens=seq(0,128, by=2), StDens=seq(0,128, by=2), TempNum=c(16,20,24,28,32), Replicate = c("A", "B"))
newData <- newData %>%
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T)))

newData$preds <- predict(StephSurvivalModel, type = "response", newdata = newData)
#get means over replicates to plot
predicted <- newData %>%
  group_by(TempNum, AeDens, StDens) %>%
  summarise(preds = mean(preds))
#remove extrapolation outside of measured range
predicted$preds[predicted$AeDens+predicted$StDens>128] <- NA  

#plot it
ggplot(predicted, aes(x=StDens, y=AeDens, z=preds))+
  geom_raster(aes(fill=preds))+
  geom_contour(color="gray90")+
  theme_minimal()+
  scale_fill_viridis(name="Prop. Emerged")+
  facet_wrap(~TempNum, ncol = 5) +
  xlab("Stephensi Density") +
  ylab("Aegypti Density")
```


# Fecundity

Split into Two Dataframes. Change the NAs of those that didn't lay to 0.

```{r}
aeFec <- dplyr::filter(fecundity, Species == "Aedes")
aeFec$Eggs[is.na(aeFec$Eggs)] <- 0
stFec <- dplyr::filter(fecundity, Species == "Stephensi")
stFec$Eggs[is.na(stFec$Eggs)] <- 0
```


We will use a zero-inflated mixed model here from the `glmmADMB` package because we have many zeros, and this drastically improved model fit during preliminary explorations. Note that these models take a long time to run.

## Aedes

Model Selection

```{r, warning = F}
m0 <- glmmadmb(Eggs ~ 1 + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

m1 <- glmmadmb(Eggs ~ TempNum + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

m2 <- glmmadmb(Eggs ~ AeDens + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

m3 <- glmmadmb(Eggs ~ AeDens + StDens + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

m4 <- glmmadmb(Eggs ~ AeDens + TempNum + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

m5 <- glmmadmb(Eggs ~ AeDens + poly(TempNum,2) + (1|Replicate),
                  data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

#best model with no 
m5old <- glmer(Eggs ~ AeDens + poly(TempNum,2) + (1|Replicate),
                  data = aeFec,
                  family=gaussian)

m6 <- glmmadmb(Eggs ~ AeDens*poly(TempNum,2) + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

m7 <- glmmadmb(Eggs ~ AeDens*TempNum + (1|Replicate),
                   data = aeFec,
                    zeroInflation=TRUE, 
                    family="nbinom")

```

```{r}
modelSummary <- cbind(model = c("m0","m1","m2","m3", "m4", "m5", "m6", "m7"), 
                   logLik = logLik(m0, m1, m2, m3, m4, m5, m6, m7),
                   AIC = AIC(m0, m1, m2, m3, m4, m5, m6, m7),
                   AICc = AICc(m0, m1, m2, m3, m4, m5, m6, m7), 
                   AICweights = Weights(AIC(m0, m1, m2, m3, m4, m5, m6, m7)))
modelSummary
anova(m4, m5,m6, m7)

AedesFecundityModel <- m5
#AedesFecundityModel <- m5old

```

The best fitting model is m5 (AeDens + TempNum +StDens).

```{r}
summary(AedesFecundityModel)

confint(AedesFecundityModel)
```


```{r}
plot(AedesFecundityModel, id = 0.01, idLabels=~.obs)
qqnorm(resid(AedesFecundityModel))
qqline(resid(AedesFecundityModel), col = "red")

aeFec$preds <- predict(AedesFecundityModel)
aeFec$resids <- resid(AedesFecundityModel)

ggplot(data = aeFec, aes(x=StDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = aeFec, aes(x=AeDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = aeFec, aes(x=TempNum, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()
```

Create heatmaps of the eggs:

```{r}
#heatmap plots
newData <- expand.grid(AeDens=seq(0,128, by=2), StDens=seq(0,128, by=2), TempNum=c(16,20,24,28,32), Replicate = c("A", "B"))
newData <- newData %>%
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T)))

newData$preds <- predict(AedesFecundityModel, type = "response", newdata = newData)
#get means over replicates to plot
predicted <- newData %>%
  group_by(TempNum, AeDens, StDens) %>%
  summarise(preds = mean(preds))
#remove extrapolation outside of measured range
predicted$preds[predicted$AeDens+predicted$StDens>128] <- NA  

#plot it
ggplot(predicted, aes(x=StDens, y=AeDens, z=preds))+
  geom_raster(aes(fill=preds))+
  geom_contour(color="gray90")+
  theme_minimal()+
  scale_fill_viridis(name="Number of Eggs Laid")+
  facet_wrap(~TempNum, ncol = 5) +
  xlab("Stephensi Density") +
  ylab("Aegypti Density")
```

## Stephensi

Model Selection

```{r}
m0 <- glmer(Eggs ~ 1 + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m1 <- glmer(Eggs ~ TempNum + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m2 <- glmer(Eggs ~ AeDens + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m3 <- glmer(Eggs ~ StDens + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m4 <- glmer(Eggs ~ AeDens + TempNum + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m5 <- glmer(Eggs ~ AeDens + poly(TempNum,2) + StDens + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m6 <- glmer(Eggs ~ AeDens*TempNum*StDens + (1|Replicate),
                   data = stFec,
                   family = gaussian)

m7 <- glmer(Eggs ~ AeDens*TempNum + StDens*TempNum + (1|Replicate),
                   data = stFec,
                   family = gaussian)

```

```{r}
modelSummary <- cbind(model = c("m0","m1","m2","m3", "m4", "m5", "m6", "m7"), 
                   do.call(rbind, lapply(list(m0, m1, m2, m3, m4, m5, m6, m7), broom::glance)),
                   AICc = AICc(m0, m1, m2, m3, m4, m5, m6, m7), 
                   AICweights = Weights(AIC(m0, m1, m2, m3, m4, m5, m6, m7)))
modelSummary

StephensiFecundityModel <- m5
```


```{r}
summary(StephensiFecundityModel)
confint(StephensiFecundityModel)
```

```{r}
plot(StephensiFecundityModel, id = 0.01, idLabels=~.obs)
qqnorm(resid(StephensiFecundityModel))
qqline(resid(StephensiFecundityModel), col = "red")

stFec$preds <- predict(StephensiFecundityModel)
stFec$resids <- resid(StephensiFecundityModel)

ggplot(data = stFec, aes(x=StDens, y = resids))+
  geom_point() +
  geom_smooth(se = F)+
  theme_base()

ggplot(data = stFec, aes(x=AeDens, y = resids))+
  geom_point() +
  geom_smooth(se = F)+
  theme_base()

ggplot(data = stFec, aes(x=TempNum, y = resids))+
  geom_point() +
  geom_smooth(se = F)+
  theme_base()
```

Create heatmaps of the eggs:

```{r, include = F}
#heatmap plots
newData <- expand.grid(AeDens=seq(0,128, by=2), StDens=seq(0,128, by=2), TempNum=c(16,20,24,28,32), Replicate = c("A", "B"))
newData <- newData %>%
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T)))

newData$preds <- predict(StephensiFecundityModel, type = "response", newdata = newData)
#get means over replicates to plot
predicted <- newData %>%
  group_by(TempNum, AeDens, StDens) %>%
  summarise(preds = mean(preds))
#remove extrapolation outside of measured range
predicted$preds[predicted$AeDens+predicted$StDens>128] <- NA  

#plot it
ggplot(predicted, aes(x=StDens, y=AeDens, z=preds))+
  geom_raster(aes(fill=preds))+
  geom_contour(color="gray90")+
  theme_minimal()+
  scale_fill_viridis(name="Number of Eggs Laid")+
  facet_wrap(~TempNum, ncol = 5) +
  xlab("Stephensi Density") +
  ylab("Aegypti Density")
```

# Growth Rate

Growth rate calculated via Sugihara based on raw data.

## Aedes

Calculate growth rate. Using raw data except for fecundity (since this was only estimated from a subset). Fecundity is estimated using models above. In the case of stephensi, it is just the mean across all treatments, since none of our covariates were significant.

```{r}
# only need female emergence
GrowthAedes <- emergenceData %>%
  filter(Species =="Aedes" & Sex == "Female") %>%
  #assume 50% female
  mutate(N0 = AeDens/2) %>%
  rename(x = Day, Ax = Number) %>%
  #don't calculate for ones that had no aedes to begin with
  filter(AeDens>0) 

#add in predicted fecundity
GrowthAedes$fwx <- predict(AedesFecundityModel, type = "response", newdata = GrowthAedes)

#calculate overall per capita growth rate
GrowthAedes <- GrowthAedes %>%
  mutate(Axfwx = Ax*fwx, xAxfwx = x*Ax*fwx) %>%
  group_by(Replicate, Temp, Ratio, TempNum, AeDens, StDens) %>%
  mutate_at(c("Axfwx", "xAxfwx"), sum, na.rm=T) %>%
  mutate(D=14) %>%
  ungroup() %>%
  mutate(r=(log((1/N0)*Axfwx))/(D+(xAxfwx/Axfwx))) %>%
  group_by(Replicate, Temp, TempNum, Ratio, AeDens, StDens, Species) %>%
  #each row is now a duplicate of the same thing so only need the first one
  slice(1) %>%
  mutate(lambda=exp(r)) %>%
  ungroup() %>%
    #rescale predictor variables
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T))) %>%
  #drop jar that was all male
  filter(!(Replicate == "A" & Temp == "24" & Ratio == "8:24")) %>%
  #drop unneccesary columns
  dplyr::select(-x, -Ax, - Sex, - N0, -fwx, - Axfwx, - xAxfwx, -D)
```

```{r}
ggplot(data =  GrowthAedes, aes(x = AeDens, y = lambda, color = Temp)) +
  geom_point() +
  geom_smooth()
```

Model Selection

```{r}
m0 <- glmer(lambda ~ 1 + (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m1 <- glmer(lambda ~ poly(TempScale,2) + (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m2 <- glmer(lambda ~ AeDensScale + (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m3 <- glmer(lambda ~ poly(AeDensScale,2)+ (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m4 <- glmer(lambda ~ AeDensScale + poly(TempScale,2) + (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m5 <- glmer(lambda ~ AeDensScale + poly(TempScale,2) + StDensScale + (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m6 <- glmer(lambda ~ AeDensScale*TempScale+ (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

m7 <- glmer(lambda ~ poly(AeDensScale,2) + poly(TempScale,2) + (1|Replicate),
                   data = GrowthAedes,
                   family = gaussian)

```

```{r}
modelSummary <- cbind(model = c("m0","m1","m2","m3", "m4", "m5", "m6", "m7"), 
                   do.call(rbind, lapply(list(m0, m1, m2, m3, m4, m5, m6, m7), broom::glance)),
                   AICc = AICc(m0, m1, m2, m3, m4, m5, m6, m7), 
                   AICweights = Weights(AIC(m0, m1, m2, m3, m4, m5, m6, m7)))
modelSummary
anova(m4, m7)

AedesGrowthModel <- m7
```

```{r}
summary(AedesGrowthModel)
confint(AedesGrowthModel)
```

```{r}
plot(AedesGrowthModel, id = 0.01, idLabels=~.obs)
qqnorm(resid(AedesGrowthModel))
qqline(resid(AedesGrowthModel), col = "red")

GrowthAedes$preds <- predict(AedesGrowthModel)
GrowthAedes$resids <- resid(AedesGrowthModel)

ggplot(data = GrowthAedes, aes(x=StDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = GrowthAedes, aes(x=AeDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = GrowthAedes, aes(x=TempNum, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

```

Create heatmaps of the growth:

```{r}
#heatmap plots
newData <- expand.grid(AeDens=seq(0,128, by=2), StDens=seq(0,128, by=2), TempNum=c(16,20,24,28,32), Replicate = c("A", "B"))
newData <- newData %>%
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T)))

newData$preds <- predict(AedesGrowthModel, type = "response", newdata = newData)
#get means over replicates to plot
predicted <- newData %>%
  group_by(TempNum, AeDens, StDens) %>%
  summarise(preds = mean(preds))
#remove extrapolation outside of measured range
predicted$preds[predicted$AeDens+predicted$StDens>128] <- NA  

#plot it
ggplot(predicted, aes(x=StDens, y=AeDens, z=preds))+
  geom_raster(aes(fill=preds))+
  geom_contour(color="gray90")+
  theme_minimal()+
  scale_fill_viridis(name="Growth Rate")+
  facet_wrap(~TempNum, ncol = 5) +
  xlab("Stephensi Density") +
  ylab("Aegypti Density") 
```

## Stephensi

```{r}
# only need female emergence
GrowthStephensi <- emergenceData %>%
  filter(Species =="Stephensi" & Sex == "Female") %>%
  #assume 50% female
  mutate(N0 = StDens/2) %>%
  rename(x = Day, Ax = Number)  %>%
  filter(StDens>0)

#add in predicted fecundity based on overall mean since model had no significance
GrowthStephensi$fwx <- mean(fecundity$Eggs[fecundity$Species == "Stephensi"], na.rm = T)

#calculate overall per capita growth rate
GrowthStephensi <- GrowthStephensi %>%
  mutate(Axfwx = Ax*fwx, xAxfwx = x*Ax*fwx) %>%
  group_by(Replicate, Temp, Ratio, TempNum, AeDens, StDens) %>%
  mutate_at(c("Axfwx", "xAxfwx"), sum, na.rm=T) %>%
  mutate(D=14) %>%
  ungroup() %>%
  mutate(r=(log((1/N0)*Axfwx))/(D+(xAxfwx/Axfwx))) %>%
  group_by(Replicate, Temp, TempNum, Ratio, AeDens, StDens, Species) %>%
  #each row is now a duplicate of the same thing so only need the first one
  slice(1) %>%
  mutate(lambda=exp(r)) %>%
  ungroup() %>%
    #rescale predictor variables
  mutate(TempScale = as.vector(scale(TempNum, center = F, scale = T))) %>%
  mutate(AeDensScale = as.vector(scale(AeDens, center = F, scale = T))) %>%
  mutate(StDensScale = as.vector(scale(StDens, center = F, scale = T))) %>%
  #drop unneccesary columns
  dplyr::select(-x, -Ax, - Sex, - N0, -fwx, - Axfwx, - xAxfwx, -D)

# NAs are truly zeros
GrowthStephensi$lambda[is.na(GrowthStephensi$lambda)] <- 0  

  
```

```{r}
ggplot(data =  GrowthStephensi, aes(x = StDens, y = lambda, color = Temp)) +
  geom_point() +
  geom_smooth(se = F)
```

Model Selection

```{r}
m0 <- glmer(lambda ~ 1 + (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m1 <- glmer(lambda ~ poly(TempScale,2) + (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m2 <- glmer(lambda ~ AeDensScale + (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m3 <- glmer(lambda ~ poly(AeDensScale,2)+ (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m4 <- glmer(lambda ~ AeDensScale + poly(TempScale,2) + (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m5 <- glmer(lambda ~ AeDensScale + poly(TempScale,2) + StDensScale + (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m6 <- glmer(lambda ~ AeDensScale*TempScale+ (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

m7 <- glmer(lambda ~ poly(AeDensScale,2) + poly(TempScale,2) + (1|Replicate),
                   data = GrowthStephensi,
                   family = gaussian)

```

```{r}
modelSummary <- cbind(model = c("m0","m1","m2","m3", "m4", "m5", "m6", "m7"), 
                   do.call(rbind, lapply(list(m0, m1, m2, m3, m4, m5, m6, m7), broom::glance)),
                   AICc = AICc(m0, m1, m2, m3, m4, m5, m6, m7), 
                   AICweights = Weights(AIC(m0, m1, m2, m3, m4, m5, m6, m7)))
modelSummary

StephensiGrowthModel <- m5
```


```{r}
summary(StephensiGrowthModel)
confint(StephensiGrowthModel)
```

```{r}
plot(StephensiGrowthModel, id = 0.01, idLabels=~.obs)
qqnorm(resid(StephensiGrowthModel))
qqline(resid(StephensiGrowthModel), col = "red")

GrowthStephensi$preds <- predict(StephensiGrowthModel)
GrowthStephensi$resids <- resid(StephensiGrowthModel)

ggplot(data = GrowthStephensi, aes(x=StDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = GrowthStephensi, aes(x=AeDens, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

ggplot(data = GrowthStephensi, aes(x=TempNum, y = resids))+
  geom_point() +
  geom_smooth(se=T)+
  theme_base()

```
